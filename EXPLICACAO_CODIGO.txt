================================================================================
    EXPLICAÃ‡ÃƒO DO CÃ“DIGO - Sistema de AnÃ¡lise de Notas
    AnÃ¡lise Completa: Backend + Frontend
================================================================================

ÃNDICE:
1. VisÃ£o Geral do Sistema
2. BACKEND - data_processor.py (Processamento de Dados)
3. BACKEND - views.py (Interface Web)
4. FRONTEND - HTML (Estrutura da PÃ¡gina)
5. FRONTEND - JavaScript (LÃ³gica e InteraÃ§Ã£o)
6. FRONTEND - Chart.js (VisualizaÃ§Ã£o de GrÃ¡ficos)
7. Fluxo Completo do Sistema

================================================================================
1. VISÃƒO GERAL DO SISTEMA
================================================================================

O sistema tem 3 camadas principais:

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     NAVEGADOR (FRONTEND)                    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚  â”‚     HTML     â”‚  â”‚  JavaScript  â”‚  â”‚   Chart.js   â”‚     â”‚
â”‚  â”‚  (Estrutura) â”‚  â”‚   (LÃ³gica)   â”‚  â”‚  (GrÃ¡ficos)  â”‚     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â”‚
                            â”‚ HTTP (JSON)
                            â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    SERVIDOR DJANGO (BACKEND)                â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚
â”‚  â”‚   views.py   â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º    â”‚data_processorâ”‚         â”‚
â”‚  â”‚  (Rotas API) â”‚                 â”‚   (Pandas)   â”‚         â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â”‚
                            â–¼
                     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                     â”‚  CSV (Dados) â”‚
                     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


FLUXO SIMPLES:
1. UsuÃ¡rio seleciona filtros no HTML
2. JavaScript coleta os valores e envia via POST
3. views.py recebe a requisiÃ§Ã£o
4. data_processor.py filtra e processa os dados
5. views.py retorna JSON com resultados
6. JavaScript recebe os dados
7. Chart.js desenha o grÃ¡fico na tela


================================================================================
2. BACKEND - DATA_PROCESSOR.PY (Processamento de Dados)
================================================================================

Arquivo responsÃ¡vel por toda a lÃ³gica de manipulaÃ§Ã£o de dados com Pandas.

--------------------------------------------------------------------------------
CLASSE: BigDataAnalytics
--------------------------------------------------------------------------------

FUNÃ‡ÃƒO: __init__()
------------------
Inicializa o processador e carrega os dados automaticamente.

    def __init__(self):
        self.csv_path = settings.CSV_DATA_PATH  # Pega caminho do CSV
        self.df = None                          # DataFrame vazio
        self._load_data()                       # Carrega tudo


--------------------------------------------------------------------------------
FUNÃ‡ÃƒO: _load_data()
--------------------
Carrega o CSV e prepara os dados para anÃ¡lise.

ETAPA 1: Carregar CSV com Pandas
---------------------------------
    self.df = pd.read_csv(
        self.csv_path,
        dtype={
            'id_nota': str,
            'id_matricula': str,
            'vlr_nota': float,
            ...
        }
    )

Por que definir dtype?
- Garante que cada coluna tenha o tipo correto
- IDs sÃ£o texto (str), nÃ£o nÃºmeros
- Notas sÃ£o decimais (float)
- Evita que Pandas "adivinhe" errado


ETAPA 2: Limpeza de Dados
--------------------------
    self.df['titulo_turma'] = self.df['titulo_turma'].str.strip()
    self.df['nome_serie'] = self.df['nome_serie'].str.strip()
    self.df['nome_disciplina'] = self.df['nome_disciplina'].str.strip()

O que faz .str.strip():
- Remove espaÃ§os no inÃ­cio e fim
- "  Turma A  " â†’ "Turma A"
- Evita problemas em filtros e agrupamentos


ETAPA 3: Criar Coluna Combinada
--------------------------------
    self.df['serie_turma'] = self.df['nome_serie'] + ' - ' + self.df['titulo_turma']

Junta duas colunas:
- "3Âº Ano" + " - " + "A" = "3Âº Ano - A"
- Facilita exibir no dropdown


ETAPA 4: Calcular Status dos Alunos
------------------------------------
    self._calculate_student_status()

Chama funÃ§Ã£o que determina se cada aluno estÃ¡ aprovado, em recuperaÃ§Ã£o ou 
reprovado.


--------------------------------------------------------------------------------
FUNÃ‡ÃƒO: _calculate_student_status()
------------------------------------
Esta Ã© a funÃ§Ã£o MAIS IMPORTANTE do sistema!

Calcula o status final de cada aluno baseado em suas notas.

CONTEXTO:
---------
Cada aluno tem 5 registros no CSV:
- Mb1 (nota do bimestre 1)
- Mb2 (nota do bimestre 2)
- Mb3 (nota do bimestre 3)
- Mb4 (nota do bimestre 4)
- MA  (mÃ©dia anual)

REGRAS DE NEGÃ“CIO:
------------------
1. REPROVADO: Se nota MA < 6
2. RECUPERAÃ‡ÃƒO: Se MA >= 6, mas alguma Mb1-4 < 6
3. APROVADO: Se todas as notas >= 6


COMO FUNCIONA O CÃ“DIGO:

Passo 1: Criar lista para armazenar resultados
-----------------------------------------------
    alunos_status = []


Passo 2: Agrupar registros por aluno
-------------------------------------
    for id_matricula, grupo_aluno in self.df.groupby('id_matricula'):

O que faz groupby:
- Separa o DataFrame em grupos
- Cada grupo contÃ©m todas as 5 notas de um aluno
- Loop processa um aluno por vez


Passo 3: Pegar a nota MA do aluno
----------------------------------
    nota_ma = grupo_aluno[grupo_aluno['tipo_nota_aval'] == 'MA']['vlr_nota']

ExplicaÃ§Ã£o:
- grupo_aluno[grupo_aluno['tipo_nota_aval'] == 'MA']
  â†’ Filtra apenas a linha onde tipo Ã© 'MA'
  
- ['vlr_nota']
  â†’ Pega o valor da nota


Passo 4: Verificar se tem nota MA
----------------------------------
    if len(nota_ma) > 0:
        nota_ma_valor = nota_ma.iloc[0]

.iloc[0] pega o primeiro (e Ãºnico) valor


Passo 5: Aplicar regra de reprovaÃ§Ã£o
-------------------------------------
    if nota_ma_valor < 6:
        status = 'Reprovado'

Se MA < 6, estÃ¡ reprovado (nÃ£o precisa verificar mais nada)


Passo 6: Se nÃ£o reprovado, verificar recuperaÃ§Ã£o
-------------------------------------------------
    else:
        notas_bimestrais = grupo_aluno[
            grupo_aluno['tipo_nota_aval'].isin(['Mb1', 'Mb2', 'Mb3', 'Mb4'])
        ]['vlr_nota']

.isin(['Mb1', 'Mb2', 'Mb3', 'Mb4']):
- Filtra apenas notas bimestrais
- Exclui a nota MA

Verificar se alguma Ã© menor que 6:
    if len(notas_bimestrais) > 0 and (notas_bimestrais < 6).any():
        status = 'RecuperaÃ§Ã£o'

.any() retorna True se PELO MENOS UMA nota Ã© menor que 6


Passo 7: Se passou em tudo
---------------------------
    else:
        status = 'Aprovado'


Passo 8: Salvar resultado
--------------------------
    alunos_status.append({
        'id_matricula': id_matricula,
        'status_aluno': status
    })

Adiciona Ã  lista um dicionÃ¡rio com ID e status do aluno


Passo 9: Criar DataFrame de status
-----------------------------------
    df_status = pd.DataFrame(alunos_status)

Converte lista de dicionÃ¡rios em DataFrame


Passo 10: Juntar com DataFrame principal
-----------------------------------------
    self.df = self.df.merge(df_status, on='id_matricula', how='left')

Merge = JOIN do SQL
- on='id_matricula': coluna de ligaÃ§Ã£o
- how='left': mantÃ©m todos os registros do df principal

Resultado: Cada registro agora tem coluna 'status_aluno'


--------------------------------------------------------------------------------
FUNÃ‡ÃƒO: get_unique_values()
---------------------------
Extrai valores Ãºnicos para popular os filtros (dropdowns).

    return {
        'filiais': sorted(df['id_filial'].unique().tolist()),
        'series_turmas': sorted(df['serie_turma'].unique().tolist()),
        'disciplinas': sorted(df['nome_disciplina'].unique().tolist()),
        'tipos_nota': sorted(df['tipo_nota_aval'].unique().tolist())
    }

Passo a passo:
1. df['id_filial'].unique()  â†’ Array com valores Ãºnicos (sem repetir)
2. .tolist()                 â†’ Converte para lista Python
3. sorted()                  â†’ Ordena alfabeticamente
4. Retorna dicionÃ¡rio

Exemplo de retorno:
    {
        'filiais': ['E001', 'E002', 'E003'],
        'disciplinas': ['HistÃ³ria', 'MatemÃ¡tica', 'PortuguÃªs'],
        ...
    }

Uso: JavaScript usa esses valores para popular os dropdowns


--------------------------------------------------------------------------------
FUNÃ‡ÃƒO: filter_data(filters)
----------------------------
Aplica filtros selecionados pelo usuÃ¡rio.

Recebe:
    filters = {
        'id_filial': 'E001',
        'nome_disciplina': 'MatemÃ¡tica',
        'status': 'Aprovado'
    }

CÃ³digo:
    df_filtered = self.df.copy()
    
    if filters.get('id_filial'):
        df_filtered = df_filtered[df_filtered['id_filial'] == filters['id_filial']]
    
    if filters.get('serie_turma'):
        df_filtered = df_filtered[df_filtered['serie_turma'] == filters['serie_turma']]
    
    # ... e assim por diante

Como funciona a filtragem:
    df_filtered[df_filtered['id_filial'] == 'E001']
    
    1. df_filtered['id_filial'] == 'E001'
       â†’ Cria array booleano: [True, True, False, True, False, ...]
    
    2. df_filtered[array_booleano]
       â†’ Retorna apenas linhas onde Ã© True

Filtros sÃ£o CUMULATIVOS (AND lÃ³gico):
- Cada filtro reduz ainda mais o dataset
- Filial E001 AND Disciplina MatemÃ¡tica AND Status Aprovado

Retorna: DataFrame filtrado


--------------------------------------------------------------------------------
FUNÃ‡ÃƒO: aggregate_data(df_filtered, chart_type)
-----------------------------------------------
Agrupa e resume dados para gerar grÃ¡ficos.

Tem 5 tipos de grÃ¡ficos:

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
TIPO 1: COMPARAÃ‡ÃƒO ENTRE ESCOLAS (comparacao_filiais)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Mostra quantos alunos por escola estÃ£o aprovados/recuperaÃ§Ã£o/reprovados.

CÃ³digo:
    # Pegar um registro por aluno
    df_alunos = df_filtered.groupby('id_matricula').first().reset_index()
    
    # Contar por filial e status
    result = df_alunos.groupby(['id_filial', 'status']).size().unstack(fill_value=0)

.first(): Pega primeira ocorrÃªncia de cada aluno (evita duplicatas)
.unstack(): Transforma em matriz (tabela cruzada)

Resultado:
             Aprovado  RecuperaÃ§Ã£o  Reprovado
id_filial                                     
E001              120           25         15
E002              135           20         10

Preparar para grÃ¡fico:
    labels = ['Escola E001', 'Escola E002', ...]
    data_aprovados = [120, 135, ...]
    data_recuperacao = [25, 20, ...]
    data_reprovados = [15, 10, ...]

Retorna:
    {
        'labels': labels,
        'datasets': [
            {'label': 'Reprovados', 'data': data_reprovados, 'color': 'vermelho'},
            {'label': 'RecuperaÃ§Ã£o', 'data': data_recuperacao, 'color': 'amarelo'},
            {'label': 'Aprovados', 'data': data_aprovados, 'color': 'verde'}
        ],
        'title': 'ComparaÃ§Ã£o entre Escolas',
        'type': 'grouped'  # Indica que Ã© grÃ¡fico com mÃºltiplas barras
    }


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
TIPO 2: MÃ‰DIA POR DISCIPLINA (media_por_disciplina)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Calcula mÃ©dia de notas de cada disciplina.

CÃ³digo:
    result = df_filtered.groupby('nome_disciplina')['vlr_nota'].mean().sort_values(ascending=False)

O que faz:
- groupby('nome_disciplina'): Agrupa por disciplina
- ['vlr_nota'].mean(): Calcula mÃ©dia das notas em cada grupo
- sort_values(ascending=False): Ordena do maior para o menor

Resultado:
    nome_disciplina
    PortuguÃªs      8.5
    HistÃ³ria       8.2
    MatemÃ¡tica     7.8

Retorna:
    {
        'labels': ['PortuguÃªs', 'HistÃ³ria', 'MatemÃ¡tica'],
        'data': [8.5, 8.2, 7.8],
        'title': 'MÃ©dia de Notas por Disciplina'
    }


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
TIPO 3: STATUS DOS ALUNOS (status_alunos)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Conta quantos alunos em cada status.

âš ï¸ ATENÃ‡ÃƒO: Precisa contar ALUNOS ÃšNICOS, nÃ£o registros!

CÃ³digo:
    alunos_por_status = df_filtered.groupby('id_matricula')['status'].first()
    result = alunos_por_status.value_counts()

Por que .first()?
- Cada aluno aparece 5 vezes (5 notas diferentes)
- .first() pega o status da primeira ocorrÃªncia
- Garante que cada aluno Ã© contado UMA VEZ APENAS

Resultado:
    Aprovado       150
    RecuperaÃ§Ã£o     30
    Reprovado       20

Retorna:
    {
        'labels': ['Aprovado', 'RecuperaÃ§Ã£o', 'Reprovado'],
        'data': [150, 30, 20],
        'title': 'Status dos Alunos (Quantidade de Alunos Ãšnicos)'
    }


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
TIPO 4: NOTAS POR TIPO DE AVALIAÃ‡ÃƒO (notas_por_tipo)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

MÃ©dia de notas em cada tipo (Mb1, Mb2, Mb3, Mb4, MA).

CÃ³digo:
    result = df_filtered.groupby('tipo_nota_aval')['vlr_nota'].mean().sort_index()

Resultado:
    MA     7.8
    Mb1    7.2
    Mb2    7.5
    Mb3    7.4
    Mb4    7.6

Retorna:
    {
        'labels': ['MA', 'Mb1', 'Mb2', 'Mb3', 'Mb4'],
        'data': [7.8, 7.2, 7.5, 7.4, 7.6],
        'title': 'MÃ©dia de Notas por Tipo de AvaliaÃ§Ã£o'
    }


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
TIPO 5: ALUNOS POR FAIXA DE DESEMPENHO (alunos_por_faixa)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Divide notas em faixas e conta alunos.

CÃ³digo:
    bins = [0, 4, 6, 8, 10]
    labels_bins = ['CrÃ­tico (0-4)', 'RecuperaÃ§Ã£o (4-6)', 'Bom (6-8)', 'Excelente (8-10)']
    df_filtered['faixa_nota'] = pd.cut(df_filtered['vlr_nota'], bins=bins, labels=labels_bins)

O que faz pd.cut():
- Transforma valores contÃ­nuos em categorias
- Nota 3.5 â†’ 'CrÃ­tico (0-4)'
- Nota 7.2 â†’ 'Bom (6-8)'
- Nota 9.0 â†’ 'Excelente (8-10)'

Contar alunos Ãºnicos por faixa:
    result = df_filtered.groupby('faixa_nota')['id_matricula'].nunique()

.nunique(): Conta IDs Ãºnicos (nÃ£o conta duplicatas)

Resultado:
    CrÃ­tico (0-4)          40
    RecuperaÃ§Ã£o (4-6)      80
    Bom (6-8)             180
    Excelente (8-10)      150

Retorna:
    {
        'labels': ['CrÃ­tico (0-4)', 'RecuperaÃ§Ã£o (4-6)', 'Bom (6-8)', 'Excelente (8-10)'],
        'data': [40, 80, 180, 150],
        'title': 'Quantidade de Alunos por Faixa de Desempenho'
    }


--------------------------------------------------------------------------------
FUNÃ‡ÃƒO: get_statistics(df_filtered)
-----------------------------------
Calcula estatÃ­sticas gerais dos dados filtrados.

CÃ³digo:
    # Contar alunos Ãºnicos por status
    alunos_por_status = df_filtered.groupby('id_matricula')['status'].first()
    status_counts = alunos_por_status.value_counts().to_dict()
    
    return {
        'total_registros': len(df_filtered),
        'media_geral': round(df_filtered['vlr_nota'].mean(), 2),
        'nota_maxima': round(df_filtered['vlr_nota'].max(), 2),
        'nota_minima': round(df_filtered['vlr_nota'].min(), 2),
        'total_alunos': df_filtered['id_matricula'].nunique(),
        'aprovados': status_counts.get('Aprovado', 0),
        'recuperacao': status_counts.get('RecuperaÃ§Ã£o', 0),
        'reprovados': status_counts.get('Reprovado', 0)
    }

OperaÃ§Ãµes Pandas:
- len(df): Conta linhas
- .mean(): MÃ©dia
- .max(): Valor mÃ¡ximo
- .min(): Valor mÃ­nimo
- .nunique(): Conta valores Ãºnicos


================================================================================
3. BACKEND - VIEWS.PY (Interface Web)
================================================================================

Gerencia a comunicaÃ§Ã£o entre navegador e processador de dados.

--------------------------------------------------------------------------------
VARIÃVEL GLOBAL: analytics_engine
----------------------------------
    analytics_engine = BigDataAnalytics()

- Cria UMA INSTÃ‚NCIA quando o servidor inicia
- Carrega dados uma vez
- Reutiliza para todas as requisiÃ§Ãµes
- Mais eficiente que carregar dados toda vez


--------------------------------------------------------------------------------
FUNÃ‡ÃƒO: dashboard(request)
--------------------------
Renderiza a pÃ¡gina principal do dashboard.

Fluxo:
1. UsuÃ¡rio acessa http://localhost:8000
2. Django chama essa funÃ§Ã£o
3. FunÃ§Ã£o pega valores Ãºnicos (filiais, disciplinas, etc)
4. Renderiza template HTML com esses dados

CÃ³digo:
    def dashboard(request):
        unique_values = analytics_engine.get_unique_values()
        
        context = {
            'filiais': unique_values['filiais'],
            'series_turmas': unique_values['series_turmas'],
            'disciplinas': unique_values['disciplinas'],
            'tipos_nota': unique_values['tipos_nota'],
            'status_options': ['Aprovado', 'RecuperaÃ§Ã£o', 'Reprovado']
        }
        
        return render(request, 'analytics/dashboard.html', context)

context: DicionÃ¡rio que o template HTML pode acessar
render(): Processa o HTML e retorna para o navegador


--------------------------------------------------------------------------------
FUNÃ‡ÃƒO: get_chart_data(request)
-------------------------------
API que retorna dados do grÃ¡fico (JSON).

Tipo: POST
URL: /api/chart-data/

Passo 1: Receber dados do JavaScript
-------------------------------------
    data = json.loads(request.body)
    filters = {
        'id_filial': data.get('id_filial', ''),
        'serie_turma': data.get('serie_turma', ''),
        'nome_disciplina': data.get('nome_disciplina', ''),
        'tipo_nota_aval': data.get('tipo_nota_aval', ''),
        'status': data.get('status', '')
    }

json.loads(): Converte JSON em dicionÃ¡rio Python
data.get('chave', ''): Pega valor, ou '' se nÃ£o existir


Passo 2: Remover filtros vazios
--------------------------------
    filters = {k: v for k, v in filters.items() if v}

CompreensÃ£o de dicionÃ¡rio:
- Percorre cada par chave-valor
- MantÃ©m apenas se valor nÃ£o Ã© vazio ('')


Passo 3: Filtrar dados
-----------------------
    df_filtered = analytics_engine.filter_data(filters)


Passo 4: Agregar para grÃ¡fico
------------------------------
    chart_type = data.get('chart_type', 'distribuicao_notas')
    chart_data = analytics_engine.aggregate_data(df_filtered, chart_type)


Passo 5: Calcular estatÃ­sticas
-------------------------------
    statistics = analytics_engine.get_statistics(df_filtered)


Passo 6: Retornar JSON
-----------------------
    return JsonResponse({
        'success': True,
        'chart_data': chart_data,
        'statistics': statistics
    })

JsonResponse: Converte dicionÃ¡rio Python em JSON


Tratamento de erros:
    try:
        # ... todo o cÃ³digo acima ...
    except Exception as e:
        return JsonResponse({
            'success': False,
            'error': str(e)
        }, status=400)

Se algo der errado, retorna erro ao invÃ©s de quebrar


--------------------------------------------------------------------------------
FUNÃ‡ÃƒO: generate_report(request)
--------------------------------
Gera dados estruturados para relatÃ³rio.

Similar a get_chart_data(), mas organiza em formato de relatÃ³rio:
    report = {
        'titulo': 'RelatÃ³rio de AnÃ¡lise de Notas',
        'filtros_aplicados': filters,
        'grafico': chart_data,
        'estatisticas': statistics
    }


================================================================================
4. FRONTEND - HTML (Estrutura da PÃ¡gina)
================================================================================

Arquivo: analytics/templates/analytics/dashboard.html

O HTML define a estrutura visual da pÃ¡gina.

--------------------------------------------------------------------------------
SEÃ‡ÃƒO 1: FILTROS
----------------

<div class="filters-section">
    <h2>ğŸ” Filtros de AnÃ¡lise</h2>
    
    <select id="id_filial">
        <option value="">Todas as Escolas</option>
        {% for filial in filiais %}
        <option value="{{ filial }}">Escola {{ filial }}</option>
        {% endfor %}
    </select>
    
    <!-- Mais filtros... -->
</div>

{% for filial in filiais %}:
- Template Django que percorre lista de filiais
- Para cada filial, cria uma <option>

Resultado no navegador:
    <option value="E001">Escola E001</option>
    <option value="E002">Escola E002</option>
    <option value="E003">Escola E003</option>

id="id_filial":
- JavaScript usa esse ID para pegar o valor selecionado


--------------------------------------------------------------------------------
SEÃ‡ÃƒO 2: TIPOS DE GRÃFICO
--------------------------

<div class="chart-type-section">
    <input type="radio" id="chart_comparacao_filiais" 
           name="chart_type" value="comparacao_filiais" checked>
    <label for="chart_comparacao_filiais">ComparaÃ§Ã£o entre Escolas</label>
    
    <input type="radio" id="chart_media_disciplina" 
           name="chart_type" value="media_por_disciplina">
    <label for="chart_media_disciplina">MÃ©dia por Disciplina</label>
    
    <!-- Mais opÃ§Ãµes... -->
</div>

type="radio": Permite selecionar apenas uma opÃ§Ã£o
name="chart_type": Agrupa os radio buttons
value="comparacao_filiais": Valor enviado ao servidor
checked: OpÃ§Ã£o selecionada por padrÃ£o


--------------------------------------------------------------------------------
SEÃ‡ÃƒO 3: BOTÃ•ES
---------------

<button class="btn btn-primary" onclick="loadChartData()">
    ğŸ”„ Atualizar GrÃ¡fico
</button>

<button class="btn btn-secondary" onclick="printReport()">
    ğŸ–¨ï¸ Imprimir RelatÃ³rio
</button>

<button class="btn btn-tertiary" onclick="clearFilters()">
    ğŸ—‘ï¸ Limpar Filtros
</button>

onclick="loadChartData()":
- Quando usuÃ¡rio clica, chama funÃ§Ã£o JavaScript loadChartData()


--------------------------------------------------------------------------------
SEÃ‡ÃƒO 4: ESTATÃSTICAS
----------------------

<div id="statistics" class="statistics-section" style="display: none;">
    <!-- JavaScript preenche aqui dinamicamente -->
</div>

display: none: Inicialmente oculto
JavaScript preenche quando recebe dados


--------------------------------------------------------------------------------
SEÃ‡ÃƒO 5: GRÃFICO
----------------

<div class="chart-section">
    <h2 id="chartTitle">Selecione os filtros e clique em "Atualizar GrÃ¡fico"</h2>
    <canvas id="chartCanvas"></canvas>
</div>

<canvas>: Elemento HTML onde Chart.js desenha o grÃ¡fico
id="chartCanvas": JavaScript usa esse ID para desenhar


================================================================================
5. FRONTEND - JAVASCRIPT (LÃ³gica e InteraÃ§Ã£o)
================================================================================

Todo o cÃ³digo JavaScript estÃ¡ dentro de <script> no dashboard.html.

--------------------------------------------------------------------------------
VARIÃVEIS GLOBAIS
-----------------

let currentChart = null;         // ReferÃªncia ao grÃ¡fico atual
let currentChartData = null;     // Dados do grÃ¡fico
let currentStatistics = null;    // EstatÃ­sticas atuais
let currentFilters = null;       // Filtros aplicados

Globais porque precisam ser acessadas por vÃ¡rias funÃ§Ãµes.


--------------------------------------------------------------------------------
FUNÃ‡ÃƒO: getCookie(name)
-----------------------
Pega o CSRF token dos cookies.

    function getCookie(name) {
        let cookieValue = null;
        if (document.cookie && document.cookie !== '') {
            const cookies = document.cookie.split(';');
            for (let i = 0; i < cookies.length; i++) {
                const cookie = cookies[i].trim();
                if (cookie.substring(0, name.length + 1) === (name + '=')) {
                    cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                    break;
                }
            }
        }
        return cookieValue;
    }

O que faz:
1. Pega todos os cookies do navegador
2. Divide por ';' (cookies sÃ£o separados assim)
3. Procura o cookie com o nome especÃ­fico
4. Retorna o valor do cookie

Por que CSRF token?
- Django exige para requisiÃ§Ãµes POST
- SeguranÃ§a contra ataques CSRF
- Token Ã© gerado automaticamente pelo Django


--------------------------------------------------------------------------------
FUNÃ‡ÃƒO: loadChartData() â­ (FUNÃ‡ÃƒO PRINCIPAL)
--------------------------------------------
Esta Ã© a funÃ§Ã£o mais importante do frontend!

Ã‰ chamada quando usuÃ¡rio clica em "Atualizar GrÃ¡fico".


Passo 1: Coletar valores dos filtros
-------------------------------------
    const filters = {
        id_filial: document.getElementById('id_filial').value,
        serie_turma: document.getElementById('serie_turma').value,
        nome_disciplina: document.getElementById('nome_disciplina').value,
        tipo_nota_aval: document.getElementById('tipo_nota_aval').value,
        status: document.getElementById('status').value,
        chart_type: document.querySelector('input[name="chart_type"]:checked').value
    };

document.getElementById('id_filial').value:
- Pega o elemento HTML com id="id_filial"
- .value retorna o valor selecionado no dropdown

document.querySelector('input[name="chart_type"]:checked'):
- Pega o radio button selecionado (checked)
- .value retorna o valor (ex: 'media_por_disciplina')


Passo 2: Armazenar filtros
---------------------------
    currentFilters = filters;

Salva para usar depois (ex: na impressÃ£o do relatÃ³rio)


Passo 3: Mostrar mensagem de loading
-------------------------------------
    document.getElementById('chartTitle').textContent = 'Carregando dados...';


Passo 4: Fazer requisiÃ§Ã£o ao servidor
--------------------------------------
    const response = await fetch('/api/chart-data/', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': csrftoken
        },
        body: JSON.stringify(filters)
    });

fetch(): Faz requisiÃ§Ã£o HTTP assÃ­ncrona
- URL: '/api/chart-data/'
- method: 'POST'
- headers: CabeÃ§alhos da requisiÃ§Ã£o
  - 'Content-Type': Informa que estÃ¡ enviando JSON
  - 'X-CSRFToken': Token de seguranÃ§a do Django
- body: Dados enviados (filtros convertidos para JSON)

await: Espera a resposta do servidor
JSON.stringify(): Converte objeto JavaScript para string JSON


Passo 5: Processar resposta
----------------------------
    const data = await response.json();

response.json(): Converte resposta JSON em objeto JavaScript


Passo 6: Verificar sucesso e atualizar pÃ¡gina
----------------------------------------------
    if (data.success) {
        currentChartData = data.chart_data;
        currentStatistics = data.statistics;
        
        updateStatistics(data.statistics);
        updateChart(data.chart_data);
    } else {
        alert('Erro ao carregar dados: ' + data.error);
    }

Se sucesso:
- Salva dados em variÃ¡veis globais
- Chama funÃ§Ã£o para atualizar estatÃ­sticas
- Chama funÃ§Ã£o para atualizar grÃ¡fico

Se erro:
- Mostra mensagem de erro ao usuÃ¡rio


Passo 7: Tratar erros de conexÃ£o
---------------------------------
    try {
        // ... todo cÃ³digo acima ...
    } catch (error) {
        console.error('Erro:', error);
        alert('Erro ao conectar com o servidor');
    }

catch: Captura erros (ex: servidor fora do ar)


--------------------------------------------------------------------------------
FUNÃ‡ÃƒO: updateStatistics(stats)
-------------------------------
Atualiza as estatÃ­sticas na tela.

    function updateStatistics(stats) {
        const statsSection = document.getElementById('statistics');
        statsSection.style.display = 'grid';
        
        statsSection.innerHTML = `
            <div class="stat-card">
                <h3>Total de Registros</h3>
                <p>${stats.total_registros.toLocaleString('pt-BR')}</p>
            </div>
            <div class="stat-card">
                <h3>Total de Alunos</h3>
                <p>${stats.total_alunos.toLocaleString('pt-BR')}</p>
            </div>
            ...
        `;
    }

O que faz:
1. Pega elemento HTML com id="statistics"
2. Torna visÃ­vel (display: 'grid')
3. innerHTML = ...: Substitui conteÃºdo interno
4. Template string (`...`): Cria HTML dinÃ¢mico
5. ${stats.total_registros}: Insere valor no HTML

.toLocaleString('pt-BR'):
- Formata nÃºmero no padrÃ£o brasileiro
- 50000 â†’ "50.000"


--------------------------------------------------------------------------------
FUNÃ‡ÃƒO: updateChart(chartData) â­
--------------------------------
Atualiza o grÃ¡fico na tela usando Chart.js.


Passo 1: Pegar contexto do canvas
----------------------------------
    const ctx = document.getElementById('chartCanvas').getContext('2d');

getContext('2d'): Prepara canvas para desenho 2D


Passo 2: Destruir grÃ¡fico anterior
-----------------------------------
    if (currentChart) {
        currentChart.destroy();
    }

Se jÃ¡ existe grÃ¡fico, remove antes de criar novo


Passo 3: Atualizar tÃ­tulo
--------------------------
    document.getElementById('chartTitle').textContent = chartData.title;


Passo 4: Determinar tipo de grÃ¡fico
------------------------------------
    const chartType = document.querySelector('input[name="chart_type"]:checked').value;
    let chartTypeDisplay = 'bar';  // PadrÃ£o: barras
    
    if (chartType === 'status_alunos' || chartType === 'alunos_por_faixa') {
        chartTypeDisplay = 'pie';  // Pizza para esses tipos
    }

Chart.js suporta:
- 'bar': GrÃ¡fico de barras
- 'pie': GrÃ¡fico de pizza
- 'line': GrÃ¡fico de linha
- etc.


Passo 5: Preparar datasets
---------------------------

CASO 1: GrÃ¡fico agrupado (mÃºltiplas barras)
    if (chartData.type === 'grouped' && chartData.datasets) {
        datasets = chartData.datasets.map(ds => ({
            label: ds.label,
            data: ds.data,
            backgroundColor: ds.color,
            borderColor: ds.color.replace('0.7', '1'),
            borderWidth: 2
        }));
    }

.map(): Transforma cada item da lista
Cada dataset vira um objeto com configuraÃ§Ãµes Chart.js

Exemplo:
    chartData.datasets = [
        {label: 'Aprovados', data: [120, 135], color: 'rgba(40, 167, 69, 0.7)'},
        {label: 'Reprovados', data: [15, 10], color: 'rgba(220, 53, 69, 0.7)'}
    ]
    
    Vira:
    datasets = [
        {
            label: 'Aprovados',
            data: [120, 135],
            backgroundColor: 'rgba(40, 167, 69, 0.7)',
            borderColor: 'rgba(40, 167, 69, 1)',
            borderWidth: 2
        },
        {
            label: 'Reprovados',
            data: [15, 10],
            backgroundColor: 'rgba(220, 53, 69, 0.7)',
            borderColor: 'rgba(220, 53, 69, 1)',
            borderWidth: 2
        }
    ]


CASO 2: GrÃ¡fico simples (uma sÃ©rie)
    datasets = [{
        label: chartData.title,
        data: chartData.data,
        backgroundColor: [
            'rgba(102, 126, 234, 0.7)',
            'rgba(118, 75, 162, 0.7)',
            'rgba(40, 167, 69, 0.7)',
            ...
        ],
        borderColor: [
            'rgba(102, 126, 234, 1)',
            'rgba(118, 75, 162, 1)',
            'rgba(40, 167, 69, 1)',
            ...
        ],
        borderWidth: 2
    }];

Array de cores: Uma cor para cada barra/fatia


Passo 6: Criar grÃ¡fico com Chart.js
------------------------------------
    currentChart = new Chart(ctx, {
        type: chartTypeDisplay,
        data: {
            labels: chartData.labels,
            datasets: datasets
        },
        options: {
            responsive: true,
            maintainAspectRatio: true,
            plugins: {
                legend: {
                    display: chartTypeDisplay === 'pie' || (chartData.type === 'grouped'),
                    position: 'bottom'
                },
                tooltip: {
                    enabled: true,
                    backgroundColor: 'rgba(0, 0, 0, 0.8)',
                    padding: 12
                }
            },
            scales: chartTypeDisplay === 'bar' ? {
                y: {
                    beginAtZero: true
                }
            } : {}
        }
    });

new Chart(): Cria novo grÃ¡fico
- ctx: Onde desenhar (canvas)
- type: Tipo do grÃ¡fico ('bar', 'pie', etc)
- data: Dados e labels
- options: ConfiguraÃ§Ãµes visuais

OpÃ§Ãµes importantes:
- responsive: true â†’ Ajusta ao tamanho da tela
- legend.display â†’ Mostra legenda apenas quando necessÃ¡rio
- legend.position: 'bottom' â†’ Legenda embaixo
- tooltip.enabled â†’ Mostra valores ao passar mouse
- scales.y.beginAtZero â†’ Eixo Y comeÃ§a no zero

Chart.js automaticamente:
- Desenha o grÃ¡fico
- Anima a entrada
- Adiciona interatividade (hover, tooltips)
- Responsividade


--------------------------------------------------------------------------------
FUNÃ‡ÃƒO: printReport()
---------------------
Gera e imprime relatÃ³rio em nova janela.


Passo 1: Validar se tem dados
------------------------------
    if (!currentChartData || !currentStatistics) {
        alert('Por favor, gere um grÃ¡fico primeiro antes de imprimir!');
        return;
    }


Passo 2: Criar HTML do relatÃ³rio
---------------------------------
    let reportContent = `
        <!DOCTYPE html>
        <html>
        <head>
            <title>RelatÃ³rio de AnÃ¡lise de Notas</title>
            <style>
                /* CSS inline para impressÃ£o */
                body { font-family: Arial; padding: 40px; }
                h1 { color: #667eea; }
                ...
            </style>
        </head>
        <body>
            <h1>ğŸ“Š RelatÃ³rio de AnÃ¡lise de Notas</h1>
            
            <h2>Filtros Aplicados</h2>
            <div>Escola: ${currentFilters.id_filial || 'Todas'}</div>
            ...
            
            <h2>EstatÃ­sticas Gerais</h2>
            <div>Total: ${currentStatistics.total_alunos}</div>
            ...
            
            <h2>${currentChartData.title}</h2>
            <table>
                <thead>
                    <tr><th>Item</th><th>Valor</th></tr>
                </thead>
                <tbody>
    `;

Template string com HTML completo


Passo 3: Adicionar dados do grÃ¡fico na tabela
----------------------------------------------
    for (let i = 0; i < currentChartData.labels.length; i++) {
        reportContent += `
            <tr>
                <td>${currentChartData.labels[i]}</td>
                <td>${currentChartData.data[i]}</td>
            </tr>
        `;
    }

Loop que cria uma linha <tr> para cada item


Passo 4: Fechar HTML
--------------------
    reportContent += `
                </tbody>
            </table>
        </body>
        </html>
    `;


Passo 5: Abrir nova janela
---------------------------
    const printWindow = window.open('', '', 'width=900,height=700');

window.open(): Abre nova janela do navegador


Passo 6: Escrever HTML na janela
---------------------------------
    printWindow.document.write(reportContent);
    printWindow.document.close();
    printWindow.focus();


Passo 7: Imprimir
-----------------
    setTimeout(() => {
        printWindow.print();
    }, 250);

setTimeout: Aguarda 250ms para HTML carregar
printWindow.print(): Abre diÃ¡logo de impressÃ£o


--------------------------------------------------------------------------------
FUNÃ‡ÃƒO: clearFilters()
----------------------
Limpa todos os filtros e reseta a pÃ¡gina.

    function clearFilters() {
        document.getElementById('id_filial').value = '';
        document.getElementById('serie_turma').value = '';
        ...
        
        document.getElementById('statistics').style.display = 'none';
        
        if (currentChart) {
            currentChart.destroy();
            currentChart = null;
        }
    }

O que faz:
1. Define todos os selects para '' (opÃ§Ã£o padrÃ£o)
2. Marca primeiro radio button
3. Oculta estatÃ­sticas
4. DestrÃ³i grÃ¡fico
5. Limpa variÃ¡veis globais


--------------------------------------------------------------------------------
EVENTO: window.addEventListener('load')
---------------------------------------
Executa quando pÃ¡gina carrega completamente.

    window.addEventListener('load', function() {
        loadChartData();
    });

Automaticamente carrega dados iniciais (sem filtros) quando abre a pÃ¡gina.


================================================================================
6. FRONTEND - CHART.JS (VisualizaÃ§Ã£o de GrÃ¡ficos)
================================================================================

Chart.js Ã© uma biblioteca JavaScript para criar grÃ¡ficos.

Ã‰ incluÃ­da no base.html:
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>


CRIAÃ‡ÃƒO DE GRÃFICO
------------------
    new Chart(ctx, {
        type: 'bar',
        data: {...},
        options: {...}
    })


PARÃ‚METROS PRINCIPAIS:

1. type: Tipo do grÃ¡fico
   ----------------------
   - 'bar': Barras verticais
   - 'pie': Pizza
   - 'line': Linha
   - 'doughnut': Rosca
   - 'radar': Radar


2. data: Dados do grÃ¡fico
   ----------------------
   {
       labels: ['Item 1', 'Item 2', 'Item 3'],
       datasets: [{
           label: 'SÃ©rie 1',
           data: [10, 20, 30],
           backgroundColor: ['red', 'green', 'blue']
       }]
   }

   labels: RÃ³tulos do eixo X (ou nomes das fatias)
   datasets: Array de sÃ©ries de dados
   data: Valores numÃ©ricos
   backgroundColor: Cores


3. options: ConfiguraÃ§Ãµes
   -----------------------
   {
       responsive: true,          // Ajusta ao tamanho do container
       maintainAspectRatio: true, // MantÃ©m proporÃ§Ã£o
       plugins: {
           legend: {
               display: true,     // Mostra legenda
               position: 'bottom' // PosiÃ§Ã£o: 'top', 'bottom', 'left', 'right'
           },
           tooltip: {
               enabled: true      // Mostra tooltip ao passar mouse
           }
       },
       scales: {
           y: {
               beginAtZero: true  // Eixo Y comeÃ§a em zero
           }
       }
   }


GRÃFICO DE BARRAS AGRUPADAS
----------------------------
Para comparaÃ§Ã£o entre escolas (3 barras por escola):

    datasets: [
        {
            label: 'Aprovados',
            data: [120, 135, 140],
            backgroundColor: 'rgba(40, 167, 69, 0.7)'
        },
        {
            label: 'RecuperaÃ§Ã£o',
            data: [25, 20, 18],
            backgroundColor: 'rgba(255, 193, 7, 0.7)'
        },
        {
            label: 'Reprovados',
            data: [15, 10, 12],
            backgroundColor: 'rgba(220, 53, 69, 0.7)'
        }
    ]

Chart.js automaticamente agrupa as barras


GRÃFICO DE PIZZA
----------------
Para status dos alunos:

    type: 'pie',
    data: {
        labels: ['Aprovado', 'RecuperaÃ§Ã£o', 'Reprovado'],
        datasets: [{
            data: [150, 30, 20],
            backgroundColor: [
                'rgba(40, 167, 69, 0.7)',
                'rgba(255, 193, 7, 0.7)',
                'rgba(220, 53, 69, 0.7)'
            ]
        }]
    }


INTERATIVIDADE AUTOMÃTICA
--------------------------
Chart.js adiciona automaticamente:
- Hover: Destaca barra/fatia ao passar mouse
- Tooltip: Mostra valor ao passar mouse
- AnimaÃ§Ã£o: Anima entrada do grÃ¡fico
- Click: Pode detectar cliques (se configurado)
- Responsividade: Ajusta ao redimensionar janela


DESTRUIÃ‡ÃƒO DE GRÃFICO
----------------------
Antes de criar novo grÃ¡fico, destruir o anterior:

    if (currentChart) {
        currentChart.destroy();
    }

Libera memÃ³ria e limpa canvas


================================================================================
7. FLUXO COMPLETO DO SISTEMA
================================================================================

CENÃRIO: UsuÃ¡rio quer ver mÃ©dia por disciplina na Escola E001

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ PASSO 1: UsuÃ¡rio Interage                                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

AÃ§Ã£o no Navegador:
1. Seleciona "Escola E001" no dropdown de filial
2. Seleciona "MÃ©dia por Disciplina" no tipo de grÃ¡fico
3. Clica em botÃ£o "Atualizar GrÃ¡fico"

JavaScript detecta:
    onclick="loadChartData()"  â†’  Chama funÃ§Ã£o


â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ PASSO 2: JavaScript Coleta Dados                                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

FunÃ§Ã£o loadChartData():
    const filters = {
        id_filial: 'E001',           // Do dropdown
        serie_turma: '',              // Vazio (todas)
        nome_disciplina: '',          // Vazio (todas)
        tipo_nota_aval: '',           // Vazio (todos)
        status: '',                   // Vazio (todos)
        chart_type: 'media_por_disciplina'  // Do radio button
    };


â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ PASSO 3: Envia RequisiÃ§Ã£o ao Servidor                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

JavaScript:
    fetch('/api/chart-data/', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': csrftoken
        },
        body: JSON.stringify(filters)
    })

Dados enviados (JSON):
    {
        "id_filial": "E001",
        "serie_turma": "",
        "nome_disciplina": "",
        "tipo_nota_aval": "",
        "status": "",
        "chart_type": "media_por_disciplina"
    }


â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ PASSO 4: Django Recebe RequisiÃ§Ã£o                                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

views.py - get_chart_data():
    data = json.loads(request.body)
    # data = {'id_filial': 'E001', 'chart_type': 'media_por_disciplina', ...}
    
    filters = {k: v for k, v in data.items() if v and k != 'chart_type'}
    # filters = {'id_filial': 'E001'}  (apenas nÃ£o vazios)


â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ PASSO 5: Filtra Dados com Pandas                                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

data_processor.py - filter_data():
    df_filtered = self.df.copy()
    df_filtered = df_filtered[df_filtered['id_filial'] == 'E001']
    # DataFrame agora tem apenas registros da Escola E001


â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ PASSO 6: Agrega Dados                                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

data_processor.py - aggregate_data():
    result = df_filtered.groupby('nome_disciplina')['vlr_nota'].mean()
    # result:
    # MatemÃ¡tica    8.2
    # PortuguÃªs     8.7
    # HistÃ³ria      8.5

    return {
        'labels': ['MatemÃ¡tica', 'PortuguÃªs', 'HistÃ³ria'],
        'data': [8.2, 8.7, 8.5],
        'title': 'MÃ©dia de Notas por Disciplina'
    }


â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ PASSO 7: Calcula EstatÃ­sticas                                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

data_processor.py - get_statistics():
    return {
        'total_registros': 45000,
        'total_alunos': 9000,
        'media_geral': 8.3,
        'nota_maxima': 10.0,
        'nota_minima': 4.5,
        'aprovados': 7200,
        'recuperacao': 1200,
        'reprovados': 600
    }


â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ PASSO 8: Django Retorna JSON                                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

views.py:
    return JsonResponse({
        'success': True,
        'chart_data': {
            'labels': ['MatemÃ¡tica', 'PortuguÃªs', 'HistÃ³ria'],
            'data': [8.2, 8.7, 8.5],
            'title': 'MÃ©dia de Notas por Disciplina'
        },
        'statistics': {
            'total_registros': 45000,
            'total_alunos': 9000,
            ...
        }
    })


â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ PASSO 9: JavaScript Recebe Resposta                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

loadChartData():
    const data = await response.json();
    
    if (data.success) {
        currentChartData = data.chart_data;
        currentStatistics = data.statistics;
        
        updateStatistics(data.statistics);
        updateChart(data.chart_data);
    }


â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ PASSO 10: Atualiza EstatÃ­sticas na Tela                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

updateStatistics():
    statsSection.innerHTML = `
        <div class="stat-card">
            <h3>Total de Alunos</h3>
            <p>9.000</p>
        </div>
        <div class="stat-card">
            <h3>MÃ©dia Geral</h3>
            <p>8.30</p>
        </div>
        ...
    `;

UsuÃ¡rio vÃª os cards coloridos com nÃºmeros atualizados


â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ PASSO 11: Desenha GrÃ¡fico com Chart.js                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

updateChart():
    currentChart = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: ['MatemÃ¡tica', 'PortuguÃªs', 'HistÃ³ria'],
            datasets: [{
                data: [8.2, 8.7, 8.5],
                backgroundColor: [
                    'rgba(102, 126, 234, 0.7)',
                    'rgba(118, 75, 162, 0.7)',
                    'rgba(40, 167, 69, 0.7)'
                ]
            }]
        },
        options: {
            responsive: true,
            scales: {
                y: { beginAtZero: true }
            }
        }
    });

Chart.js:
1. LÃª os dados
2. Calcula posiÃ§Ãµes das barras
3. Desenha no canvas
4. Anima a entrada
5. Adiciona interatividade

UsuÃ¡rio vÃª: GrÃ¡fico de barras animado mostrando as mÃ©dias!


================================================================================
RESUMO FINAL
================================================================================

ARQUITETURA EM 3 CAMADAS:

1. DADOS (data_processor.py)
   --------------------------
   - Carrega CSV com Pandas
   - Limpa e transforma dados
   - Calcula status dos alunos
   - Filtra baseado em critÃ©rios
   - Agrega para grÃ¡ficos
   - Calcula estatÃ­sticas

2. API (views.py)
   --------------
   - Recebe requisiÃ§Ãµes HTTP
   - Processa filtros
   - Chama funÃ§Ãµes do data_processor
   - Retorna JSON

3. INTERFACE (dashboard.html + JavaScript + Chart.js)
   ---------------------------------------------------
   - Exibe filtros e botÃµes
   - Coleta seleÃ§Ãµes do usuÃ¡rio
   - Envia requisiÃ§Ãµes ao servidor
   - Recebe JSON com dados
   - Atualiza estatÃ­sticas na tela
   - Desenha grÃ¡ficos interativos


FLUXO DE DADOS:

    UsuÃ¡rio seleciona filtros
            â†“
    JavaScript coleta valores
            â†“
    POST /api/chart-data/ (JSON)
            â†“
    views.py recebe requisiÃ§Ã£o
            â†“
    data_processor filtra DataFrame
            â†“
    data_processor agrega dados
            â†“
    views.py retorna JSON
            â†“
    JavaScript processa resposta
            â†“
    Atualiza estatÃ­sticas (HTML)
            â†“
    Chart.js desenha grÃ¡fico
            â†“
    UsuÃ¡rio vÃª resultado!


PONTOS-CHAVE:

âœ“ Backend e frontend sÃ£o completamente separados
âœ“ ComunicaÃ§Ã£o via JSON (formato universal)
âœ“ Pandas faz processamento pesado
âœ“ Chart.js cuida da visualizaÃ§Ã£o
âœ“ JavaScript conecta tudo

Esta arquitetura permite:
- Testar cada parte separadamente
- Trocar tecnologias facilmente
- Escalar para mais recursos
- Manter cÃ³digo organizado

================================================================================
